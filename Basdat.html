<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Database</title>
        <!-- Favicon-->
        <link rel="icon" type="image/x-icon" href="assets/img/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v5.13.0/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
        <link rel="stylesheet" href="css/style2.css">
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg bg-secondary text-uppercase fixed-top" id="mainNav">
            <div class="container">
                <a class="navbar-brand js-scroll-trigger" href="./index.html">Darul Ikhsan</a>
                <button class="navbar-toggler navbar-toggler-right text-uppercase font-weight-bold bg-primary text-white rounded" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
                    Menu
                    <i class="fas fa-bars"></i>
                </button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ml-auto">
                        <li class="nav-item mx-0 mx-lg-1"><a class="nav-link py-3 px-0 px-lg-3 rounded js-scroll-trigger" href="#page-top">TOP PAGE</a></li>
                        <!-- <li class="nav-item mx-0 mx-lg-1"><a class="nav-link py-3 px-0 px-lg-3 rounded js-scroll-trigger" href="#about">About</a></li> -->
                        <!-- <li class="nav-item mx-0 mx-lg-1"><a class="nav-link py-3 px-0 px-lg-3 rounded js-scroll-trigger" href="#TBO">theory of language and automata</a></li> -->
                        <!-- <li class="nav-item mx-0 mx-lg-1">
                            <div class="dropdown">
                                <button class="dropbtn">dropdown
                                    <i class="fa fa-caret-down"></i>
                                </button>
                                <div class="dropdown-content">
                                    <a href="#">Link 1</a>
                                    <a href="#">Link 2</a>
                                    <a href="#">Link 3</a>
                                </div>
                            </div>
                        </li> -->
                        <li class="nav-item mx-0 mx-lg-1">
                            <div class="dropdown">
                                <span>Assignment</span>
                                <div class="dropdown-content">
                                    <a href="#tugas1">Tugas 1</a>
                                    <a href="#tugas2">Tugas 2</a>
                                    <a href="#tugas3">Tugas 3</a>
                                    <a href="#tugas4">Pertemuan 9</a>
                                </div>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
        <!-- Masthead-->
        <header class="masthead bg-primary text-white text-center">
            <div class="container d-flex align-items-center flex-column">
                <!-- Masthead Avatar Image-->
                <img class="masthead-avatar mb-5" src="assets/img/avataaars.svg" alt="" />
                <!-- Masthead Heading-->
                <h1 class="masthead-heading text-uppercase mb-0">DATABASE</h1>
                <!-- Icon Divider-->
                <div class="divider-custom divider-light">
                    <div class="divider-custom-line"></div>
                    <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                    <div class="divider-custom-line"></div>
                </div>
                <!-- Masthead Subheading-->
                <!-- <p class="masthead-subheading font-weight-light mb-0">Student - Dreamer</p> -->
            </div>
        </header>
        <!-- TBO Section-->
        <section class="page-section" id="tugas1">
            <div class="container">
                <!-- TBO Section Heading-->
                <h2 class="page-section-heading text-center text-uppercase text-secondary mb-0">Pembuka</h2>
                <!-- Icon Divider-->
                <div class="divider-custom">
                    <div class="divider-custom-line"></div>
                    <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                    <div class="divider-custom-line"></div>
                </div>
                <!-- TBO Section Card-->
                <div class="card-group">
                    <div class="card">
                      <!-- <img src="..." class="card-img-top" alt="..."> -->
                      <div class="card-body">
                        <h5 class="card-title">Mengukur biaya suatu query</h5>
                        <p class="card-text">Ada beberapa kemungkinan rencana evaluasi untuk kueri, dan itu penting untuk bisa untuk membandingkan alternatif dalam hal biaya (perkiraan) mereka, dan memilih rencana terbaik. Untuk melakukannya, kita harus memperkirakan biaya operasi individu dan menggabungkannya untuk mendapatkannya biaya rencana evaluasi kueri. Jadi, saat kita mempelajari algoritma evaluasi untuk masing-masing operasi, kita juga menguraikan bagaimana memperkirakan biaya operasi. <br>Biaya evaluasi query dapat diukur dari banyaknya sumber daya (resource) sistem yang digunakan. Sumber daya yang dimaksud meliputi pengaksesan disk, waktu CPU mengerjakan query, dan untuk sistem basis data paralel atau terdistribusi. Adapun pada sistem basis data yang besar, dapat pula memberikan kontribusi biaya query yang dominan <br> Optimizer query akan membuat informasi statistik yang tersimpan dalam katalog DBMS untuk memperkirakan besarnya biaya dari sebuah rencana query. Adapun informasi yang tersimpan tersebut meliputi :
                            1. Banyaknya baris data (record) dalam sebuah tabel <br>
                            2. Banyaknya blok baris berisi baris data dalam tabel <br>
                            3. Ukuran setiap baris data dari tabel (satuan byte), dan <br>
                            4. Banyaknya nilai unik dalam tabel untuk suatu atribut..</p>
                        <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                      </div>
                    </div>
                    <!-- <div class="card"> -->
                      <!-- <img src="..." class="card-img-top" alt="..."> -->
                      <!-- <div class="card-body">
                        <h5 class="card-title">Fungsi Ilmu Teori Bahasa Dan Otomata</h5>
                        <p class="card-text">Tata bahasa adalah model yang berguna saat merancang perangkat lunak yang memproses data dengan struktur rekursif. Contoh paling terkenal adalah \ parser, "komponen kompilator yang menangani fitur bertingkat rekursif dari bahasa pemrograman tipikal, seperti ekspresi | aritmatika, bersyarat, dan seterusnya.</p>
                        <p class="card-text">Ekspresi Reguler juga menunjukkan struktur data, terutama string teks. Seperti yang akan kita lihat di Bab 3, pola string yang mereka gambarkan persis sama dengan yang bisa dijelaskan oleh nite automata. Gaya ekspresi ini berbeda secara signifikan dari gaya tata bahasa.</p> -->
                        <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                      <!-- </div>
                    </div> -->
                    <div class="card">
                      <!-- <img src="..." class="card-img-top" alt="..."> -->
                      <div class="card-body">
                        <h5 class="card-title">Evaluasi Ekspresi Oleh DBMS</h5>
                        <p class="card-text">Untuk mengevaluasi ekspresi yang membawa banyak operasi di dalamnya, kita dapat melakukan komputasi setiap operasi satu per satu. Namun, dalam sistem pemrosesan kueri, kami menggunakan dua metode untuk mengevaluasi ekspresi yang membawa banyak operasi. Metode tersebut adalah: <br>

                            1. Materialization
                            Dalam metode ini, ekspresi yang diberikan mengevaluasi satu operasi relasional dalam satu waktu. Selain itu, setiap operasi dievaluasi dalam urutan atau urutan yang sesuai. Setelah mengevaluasi semua operasi, keluarannya diwujudkan dalam hubungan sementara untuk penggunaan selanjutnya. Ini membawa metode materialisasi pada kerugian. Kerugiannya adalah bahwa ia perlu membangun hubungan sementara tersebut untuk mewujudkan hasil operasi yang dievaluasi, masing-masing. Hubungan sementara ini ditulis pada disk kecuali ukurannya kecil. <br>
                            
                            2. Pipelining
                            Pipelining adalah metode alternatif atau pendekatan untuk metode materialisasi. Dalam pipelining, ini memungkinkan kita untuk mengevaluasi setiap operasi relasional ekspresi secara bersamaan dalam pipeline. Dalam pendekatan ini, setelah mengevaluasi satu operasi, keluarannya diteruskan ke operasi berikutnya, dan rantai berlanjut hingga semua operasi relasional dievaluasi secara menyeluruh. Jadi, tidak ada persyaratan untuk menyimpan hubungan sementara dalam pemipaan. Keuntungan pipelining seperti itu membuatnya menjadi pendekatan yang lebih baik dibandingkan dengan pendekatan yang digunakan dalam metode materialisasi. Bahkan biaya dari kedua pendekatan tersebut dapat memiliki perbedaan selanjutnya di antara keduanya. Namun, kedua pendekatan tersebut menjalankan peran terbaik dalam kasus yang berbeda. Dengan demikian, kedua cara tersebut layak di tempatnya.</p>
                        <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                      </div>
                    </div>
                  </div>
            </div>
        </section>
       <!-- TBO Section tugas 2-->
       <section class="page-section" id="tugas2">
        <div class="container">
            <!-- TBO Section Heading-->
            <h2 class="page-section-heading text-center text-uppercase text-secondary mb-0">Evaluation Plan</h2>
            <!-- Icon Divider-->
            <div class="divider-custom">
                <div class="divider-custom-line"></div>
                <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                <div class="divider-custom-line"></div>
            </div>
            <!-- TBO Section Card-->
            <div class="card-group">
                <div class="card">
                  <!-- <img src="..." class="card-img-top" alt="..."> -->
                  <div class="card-body">
                    <h5 class="card-title">PROSES QUERY</h5>
                    <p class="card-text">Jadi, cara kerja dari sebuah query ialah melalui beberapa proses. Proses -proses tersebut diantaranya : <br>
                        1. Parsing — merupakan proses pertama, dimana ia memeriksa sintaks query yang ditulis. jadi jika terjadi kesalahan di sintaks, proses selanjutnya otomatis tidak akan dilakukan dan mendapatkan peringatan dari DBMS<br>
                        2. Translasi — selanjutnya, apabila query sudah benar secara sintaks, maka query tersebut akan ditranslasi menjadi aljabar relational. Hal ini musti dilakukan sebab sintaks SQL adalah bahasa pemrograman tingkat tinggi sehingga perlu dirubah ke bahasa yang dimengerti oleh mesin. <br>
                        3. Optimasi — proses ini sangat panjang untuk dapat dijabarkan secara luas. simplenya… satu buah query yang sama bisa dibuat lebih dari satu aljabar relational yang berbeda. Maka dari itu, DBMS akan memilih yang mana yang akan dieksekusi. Nah. satu ekspresi aljabar relational yang terbentuk tersebut disebut dengan istilah evaluation plan (EP). EP ini akan dihitung costnya. Cost ini diperoleh dari informasi statistik yang ada di database catalog. Ada banyak parameter biaya yang diperhitungkan. Misalnya banyaknya baris maupun blok di suatu relasi. Proses ini sangat penting jika jumlah baris query-nya sudah memasuki angka jutaan.<br>
                        4. Eksekusi — setelah evaluation plan, akan dilakukan eksekusi dan pengambilan data yang diperlukan dari database, nanti hasilnya pun akan ditampilkan di monitor</p>
                    <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                    <p class="card-text">Sebagian besar sistem database menyediakan jalan untuk menampilkan evaluation plan yang dipilih untuk menjalankan query tertentu. Biasanya paling bagus menggunakan GUI yang disediakan dengan sistem database untuk menampilkan evaluation plan. Lagi pula, jika kita menggunakan command line interface, beberapa database akan menerima berbagai perintah “explain query”, dimana menampilkan eksekusi plan terpilih untuk query tertentu. Adapun sintaks yang sebenarnya bervariasi, tergantung dari sistem database yang digunakan.</p>
                    </div>
                </div>
                <!-- <div class="card"> -->
                  <!-- <img src="..." class="card-img-top" alt="..."> -->
                  <!-- <div class="card-body">
                    <h5 class="card-title">Fungsi Ilmu Teori Bahasa Dan Otomata</h5>
                    <p class="card-text">Tata bahasa adalah model yang berguna saat merancang perangkat lunak yang memproses data dengan struktur rekursif. Contoh paling terkenal adalah \ parser, "komponen kompilator yang menangani fitur bertingkat rekursif dari bahasa pemrograman tipikal, seperti ekspresi | aritmatika, bersyarat, dan seterusnya.</p>
                    <p class="card-text">Ekspresi Reguler juga menunjukkan struktur data, terutama string teks. Seperti yang akan kita lihat di Bab 3, pola string yang mereka gambarkan persis sama dengan yang bisa dijelaskan oleh nite automata. Gaya ekspresi ini berbeda secara signifikan dari gaya tata bahasa.</p> -->
                    <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                  <!-- </div>
                </div> -->
                <!-- <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">Evaluasi Ekspresi Oleh DBMS</h5>
                        <p class="card-text">Untuk mengevaluasi ekspresi yang membawa banyak operasi di dalamnya, kita dapat melakukan komputasi setiap operasi satu per satu. Namun, dalam sistem pemrosesan kueri, kami menggunakan dua metode untuk mengevaluasi ekspresi yang membawa banyak operasi. Metode tersebut adalah: <br>

                            1. Materialization
                            Dalam metode ini, ekspresi yang diberikan mengevaluasi satu operasi relasional dalam satu waktu. Selain itu, setiap operasi dievaluasi dalam urutan atau urutan yang sesuai. Setelah mengevaluasi semua operasi, keluarannya diwujudkan dalam hubungan sementara untuk penggunaan selanjutnya. Ini membawa metode materialisasi pada kerugian. Kerugiannya adalah bahwa ia perlu membangun hubungan sementara tersebut untuk mewujudkan hasil operasi yang dievaluasi, masing-masing. Hubungan sementara ini ditulis pada disk kecuali ukurannya kecil. <br>
                            
                            2. Pipelining
                            Pipelining adalah metode alternatif atau pendekatan untuk metode materialisasi. Dalam pipelining, ini memungkinkan kita untuk mengevaluasi setiap operasi relasional ekspresi secara bersamaan dalam pipeline. Dalam pendekatan ini, setelah mengevaluasi satu operasi, keluarannya diteruskan ke operasi berikutnya, dan rantai berlanjut hingga semua operasi relasional dievaluasi secara menyeluruh. Jadi, tidak ada persyaratan untuk menyimpan hubungan sementara dalam pemipaan. Keuntungan pipelining seperti itu membuatnya menjadi pendekatan yang lebih baik dibandingkan dengan pendekatan yang digunakan dalam metode materialisasi. Bahkan biaya dari kedua pendekatan tersebut dapat memiliki perbedaan selanjutnya di antara keduanya. Namun, kedua pendekatan tersebut menjalankan peran terbaik dalam kasus yang berbeda. Dengan demikian, kedua cara tersebut layak di tempatnya.</p>
                    </div>
                </div> -->
            </div>
            <!-- TBO Section Card-->
            <div class="card-group">
                <div class="card">
                  <!-- <img src="..." class="card-img-top" alt="..."> -->
                  <div class="card-body">
                    <h5 class="card-title">Tampilan Evaluation Plan Pada MySQL</h5>
                    <p class="card-text">
                        MySQL menggunakan sintaks explain query yang sama seperti PostgreSQL. Tetapi, outputnya adalah tabel yang isinya tidak mudah dipahami. Bagaimanapun, eksekusi show warning setelah perintah explain tersebut menampilkan evaluation plan dengan format yang lebih mudah dipahami dan dibaca.
                    <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                    </div>
                </div>
            </div>
            <div class="card-group">
                <div class="card">
                    <!-- <img src="..." class="card-img-top" alt="..."> -->
                    <div class="card-body">
                      <h5 class="card-title">Contoh Menampilkan Evaluation Plan Pada MySQL</h5>
                      <img src="assets/img/1.png" class="card-img-top" alt="...">
                      <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                      </div>
                  </div>
                  <div class="card">
                    <!-- <img src="..." class="card-img-top" alt="..."> -->
                    <div class="card-body">
                      <!-- <h5 class="card-title">Contoh Menampilkan Evaluation Plan Pada MySQL</h5> -->
                      <img src="assets/img/2.png" class="card-img-top" alt="...">
                      <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                      </div>
                  </div>
            </div>
            <div class="card-group">
                <div class="card">
                    <!-- <img src="..." class="card-img-top" alt="..."> -->
                    <div class="card-body">
                      <!-- <h5 class="card-title">Contoh Menampilkan Evaluation Plan Pada MySQL</h5> -->
                      <img src="assets/img/5.png" class="card-img-top" alt="...">
                      <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                      </div>
                  </div>
                  <div class="card">
                    <!-- <img src="..." class="card-img-top" alt="..."> -->
                    <div class="card-body">
                      <!-- <h5 class="card-title">Contoh Menampilkan Evaluation Plan Pada MySQL</h5> -->
                      <img src="assets/img/4.png" class="card-img-top" alt="...">
                      <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                      </div>
                  </div>
            </div>
            <div class="card-group">
                <div class="card">
                    <!-- <img src="..." class="card-img-top" alt="..."> -->
                    <div class="card-body">
                      <!-- <h5 class="card-title">PROSES QUERY</h5> -->
                      <p class="card-text">Penjelasan dari tabel di atas, Setiap baris di EXPLAIN berisi bidang berikut:<br>
                        • id - Dalam kebanyakan kasus, bidang id akan menampilkan nomor urut SELECT query untuk baris yang di miliki. Kueri di atas tidak berisi subkueri atau gabungan, jadi id untuk kedua baris adalah 1, karena sebenarnya hanya ada 1 kueri.<br>
                        • select_type - jenis SELECT query dalam kasus ini adalah simple query karena tidak berisi subkueri atau gabungan. Dalam kasus yang lebih kompleks, ini akan berisi tipe lain seperti SUBQUERY (untuk subkueri), UNION (pernyataan kedua atau yang lebih baru dalam sebuah gabungan), DERIVED (tabel turunan) dan lainnya. Informasi lebih lanjut tentang access_types dapat ditemukan di dokumen MySQL.<br>
                        • table - nama tabel atau alias yang dirujuk baris ini. Pada gambar di atas, Anda dapat melihat 'v' dan 'p' disebutkan, karena itu adalah alias yang ditentukan untuk tabel suara dan posting.
                        <br>
                        • type - mendefinisikan bagaimana tabel diakses / digabungkan. Jenis akses paling populer yang biasanya akan Anda lihat adalah yang berikut, diurutkan dari yang terburuk hingga yang terbaik: ALL, index, range, ref, eq_ref, const, system. Seperti yang Anda lihat di JELASKAN, suara tabel adalah tabel pertama yang diakses, menggunakan ALL access_type, yang berarti MySQL akan memindai seluruh tabel, tanpa indeks, sehingga akan melalui lebih dari 14 juta catatan. Tabel posting kemudian diakses menggunakan tipe akses eq_ref. Selain tipe sistem dan konst, eq_ref adalah tipe gabungan terbaik. Database akan mengakses satu baris dari tabel ini untuk setiap kombinasi baris dari tabel sebelumnya. <br>
                        • possible_keys - Indeks opsional yang dapat dipilih MySQL, untuk mencari baris dalam tabel. Beberapa indeks dalam daftar ini sebenarnya tidak relevan, sebagai hasil dari urutan eksekusi yang dipilih MySQL. Secara umum, MySQL dapat menggunakan indeks untuk menggabungkan tabel. Dengan demikian, ia tidak akan menggunakan indeks pada kolom gabungan tabel pertama, karena ia akan tetap melalui semua barisnya (kecuali baris yang difilter oleh klausa WHERE). <br>
                        • key - Kolom ini menunjukkan indeks sebenarnya yang memutuskan untuk digunakan MySQL. Ini tidak berarti ia akan menggunakan seluruh indeks, karena ia dapat memilih untuk menggunakan hanya sebagian dari indeks, dari sisi paling kiri. <br>
                        • key_len - Ini adalah salah satu kolom penting dalam output penjelasan. Ini menunjukkan panjang kunci yang memutuskan untuk digunakan MySQL, dalam byte. Dalam EXPLAIN output di atas, MySQL menggunakan seluruh indeks PRIMARY (4 byte). Kita tahu itu karena satu-satunya kolom di indeks PRIMARY adalah Id, yang didefinisikan sebagai INT => 4 byte. Sayangnya, tidak ada cara yang lebih mudah untuk mengetahui bagian mana dari indeks yang digunakan oleh MySQL, selain menggabungkan panjang semua kolom dalam indeks dan membandingkannya dengan nilai key_len. <br>
                        • rows - Menunjukkan jumlah baris yang menurut MySQL harus diperiksa dari tabel ini, untuk menjalankan kueri. Ini hanya perkiraan. Biasanya, jumlah baris yang tinggi berarti ada ruang untuk pengoptimalan kueri. <br> 
                        • filtered - Jumlah baris yang tidak difilter oleh kondisi di klausa WHERE. Baris ini akan digabungkan ke tabel di baris berikutnya dari rencana MENJELASKAN. Seperti yang disebutkan sebelumnya, ini juga angka perkiraan, jadi MySQL bisa salah dengan perkiraan ini. <br>
                        • extra - Berisi lebih banyak informasi tentang pemrosesan kueri. Mari kita lihat ekstra untuk kueri kita: <br>
                        1. using where - Klausa WHERE digunakan untuk membatasi baris mana yang diambil dari tabel saat ini (suara) dan dicocokkan dengan tabel berikutnya (posting). <br>
                        2. using temporary - Sebagai bagian dari pemrosesan kueri, MySQL harus membuat tabel sementara, yang dalam banyak kasus dapat mengakibatkan penalti kinerja. Dalam kebanyakan kasus, ini akan menunjukkan bahwa salah satu klausa ORDER BY atau GROUP BY dijalankan tanpa menggunakan indeks. Ini juga bisa terjadi jika klausa GROUP BY dan ORDER BY menyertakan kolom berbeda (atau dalam urutan berbeda). <br>
                        3. using filesort - MySQL dipaksa untuk melakukan penerusan lain pada hasil kueri untuk mengurutkannya. Dalam banyak kasus, ini juga dapat mengakibatkan penalti kinerja.</p>
                      <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                      <p class="card-text">Sebagian besar sistem database menyediakan jalan untuk menampilkan evaluation plan yang dipilih untuk menjalankan query tertentu. Biasanya paling bagus menggunakan GUI yang disediakan dengan sistem database untuk menampilkan evaluation plan. Lagi pula, jika kita menggunakan command line interface, beberapa database akan menerima berbagai perintah “explain query”, dimana menampilkan eksekusi plan terpilih untuk query tertentu. Adapun sintaks yang sebenarnya bervariasi, tergantung dari sistem database yang digunakan.</p>
                      </div>
                  </div>
            </div>
        </div>
        </section>
         <!-- TBO Section tugas 3-->
         <section class="page-section" id="tugas3">
            <div class="container">
                <!-- TBO Section Heading-->
                <h2 class="page-section-heading text-center text-uppercase text-secondary mb-0">Proses desain Database</h2>
                <!-- Icon Divider-->
                <div class="divider-custom">
                    <div class="divider-custom-line"></div>
                    <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                    <div class="divider-custom-line"></div>
                </div>
                <!-- TBO Section Card-->
                <div class="card-group">
                    <div class="card">
                      <!-- <img src="..." class="card-img-top" alt="..."> -->
                      <div class="card-body">
                        <h5 class="card-title">1. Pengumpulan data dan analisa</h5>
                        <p class="card-text">Merupakan suatu tahap dimana kita melakukan proses indentifikasi dan analisa kebutuhan-kebutuhan data dan ini disebut pengumpulan data dan analisa. Untuk menentukan kebutuhan-kebutuhan suatu sistem database, kita harus mengenal terlebih dahulu bagian-bagian lain dari sistem informasi yang akan berinteraksi dengan sistem database, termasuk para user yang ada dan para user yang baru beserta aplikasi-aplikasinya. Kebutuhan-kebutuhan dari para user dan aplikasi-aplikasi inilah yang kemudian dikumpulkan dan dianalisa.<br> Berikut ini adalah aktifitas-aktifitas pengumpulan data dan analisa:
                            a. Menentukan kelompok pemakai dan bidang-bidang aplikasinya <br>
                            b. Peninjauan dokumentasi yang ada<br>
                            c. Analisa lingkungan operasi dan pemrosesan data <br>
                            d. Daftar pertanyaan dan wawancara</p>
                        <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                      </div>
                    </div>
                    <div class="card">
                      <!-- <img src="..." class="card-img-top" alt="..."> -->
                      <div class="card-body">
                        <h5 class="card-title">2. Perancangan database secara konseptual</h5>
                        <p class="card-text">Pada tahap ini akan dihasilkan conceptual schema untuk database yang tergantung pada sebuah DBMS yang spesifik. Sering menggunakan sebuah high-level data model seperti ER/EER modelselama tahap ini. Dalam conceptual schema, kita harus merinci aplikasi-aplikasi database yang diketahui dan transaksi-transaksi yang mungkin.Tahap perancangan database secara konseptual mempunyai 2 aktifitas pararel: <br>
                            a. Perancangan skema konseptual: <br>
                            Menguji kebutuhan-kebutuhan data dari suatu database yang merupakan hasil dari tahap 1 dan menghasilkan sebuah conceptual database schema pada DBMS-independent model data tingkat tinggi seperti EER (Enhanced Entity Relationship) model. Untuk menghasilkan skema tersebut dapat dihasilkan dengan penggabungan bermacam-macam kebutuhan user dan secara langsung membuat skema database atau dengan merancang skema-skema yang terpisah dari kebutuhan tiap-tiap user dan kemudian menggabungkan skema-skema tersebut. Model data yang digunakan pada perancangan skema konseptual adalah DBMS-independent dan langkah selanjutnya adalah memilih DBMS untuk melakukan rancangan tersebut. <br>
                            b. Perancangan transaksi <br>
                            Menguji aplikasi-aplikasi databasedimana kebutuhan-kebutuhannya telah dianalisa pada fase 1, dan menghasilkan perincian transaksi-transaksi ini.Kegunaan tahap ini yang diproses secara paralel bersama tahapp perancangan skema konseptual adalah untuk merancang karakteristik dari transaksi-transaksi database yang telah diketahui pada suatu DBMS-independent. Transaksi-transaksi ini akan digunakan untuk memproses dan memanipulasi database suatu saat dimana database tersebut dilaksanakan. <br>
                        </p>
                        <!-- <p class="card-text">Ekspresi Reguler juga menunjukkan struktur data, terutama string teks. Seperti yang akan kita lihat di Bab 3, pola string yang mereka gambarkan persis sama dengan yang bisa dijelaskan oleh nite automata. Gaya ekspresi ini berbeda secara signifikan dari gaya tata bahasa.</p> -->
                        <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                      </div>
                    </div>
                  </div>
                  <div class="card-group">
                    <div class="card">
                        <!-- <img src="..." class="card-img-top" alt="..."> -->
                        <div class="card-body">
                          <h5 class="card-title">3. Pemilihan DBMS</h5>
                          <p class="card-text">Pemilihan database ditentukan oleh beberapa faktor diantaranya faktor teknik, ekonomi, dan politik organisasi.Contoh faktor teknik: Keberadaan DBMS dalam menjalankan tugasnya seperti jenis-jenis DBMS (relational, network, hierarchical, dan lain-lain), struktur penyimpanan, dan jalur akses yang mendukung DBMS, pemakai, dan lain-lain.<br>
  
                          
                          Faktor-faktor ekonomi dan organisasi yang mempengaruhi satu sama lain dalam pemilihan DBMS: <br>
  
                          a. Struktur Data <br>
                           Jika data yang disimpan dalam database mengikuti struktur hirarki, maka suatu jenis hirarki dari DBMS harus dipikirkan.
                          <br>   
                          b. Personal yang telah terbiasa dengan suatu sistem <br>
                           Jika staf programmer dalam suatu organisasi sudah terbiasa dengan suatu DBMS, maka hal ini dapat mengurangi biaya latihan dan waktu belajar. <br>
                          c. Tersedianya layanan penjual <br>
                           Keberadaan fasilitas pelayanan penjual sangat dibutuhkan untuk membantu memecahkan beberapa masalah sistem.</p>
                          <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                        </div>
                      </div>
                      <div class="card">
                        <!-- <img src="..." class="card-img-top" alt="..."> -->
                        <div class="card-body">
                          <h5 class="card-title">4. Perancangan database secara logika (data model mapping)</h5>
                          <p class="card-text">Tahap selanjutnya adalah membuat sebuah skema konseptual dan skema eksternal pada model data dari DBMS yang terpilih. Tahap ini dilakukan oleh pemetaan skema konseptual dan skema eksternal yang dihasilkan pada tahap 2. Pada tahap ini, skema konseptual ditransformasikan dari model data tingkat tinggi yang digunakan pada tahap 2 ke dalam model data dari model data dari DBMS yang dipilih pada tahap 3. Pemetaan tersebut dapat diproses dalam 2 tingkat:<br>
  
                           a. Pemetaan system-independent <br>
                           Pemetaan ke dalam model data DBMS dengan tidak mempertimbangkan karakteristik atau hal-hal yang khusus yang berlaku pada implementasi DBMS dari    model data tersebut.
                          <br>   
                            b. Penyesuain skema ke DBMS yang spesifik<br>
                            Mengatur skema yang dihasilkan pada langkah 1 untuk disesuaikan pada implementasi yang khusus di masa yang akan datang dari suatu model data yang    digunakan pada DBMS yang dipilih.Hasil dari tahap ini memakai perintah-perintah DDL (Data Definition Language) dalam bahasa DBMS yang dipilih yang    menentukan tingkat skema konseptual dan eksternal dari sistem database. </p>
                          <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                        </div>
                      </div>
                  </div>
                  <div class="card-group">
                    <div class="card">
                        <!-- <img src="..." class="card-img-top" alt="..."> -->
                        <div class="card-body">
                          <h5 class="card-title">5. Perancangan database secara fisik</h5>
                          <p class="card-text">Perancangan database secara fisik merupakan proses pemilihan struktur-struktur penyimpanan dan jalur-jalur akses pada file-file databaseuntuk mencapai penampilan yang terbaik pada bermacam-macam aplikasi.Selama fase ini, dirancang spesifikasi-spesifikasi untuk database yang disimpan yang berhubungan dengan struktur-struktur penyimpanan fisik, penempatan record dan jalur akses. Berhubungan dengan internal schema(pada istilah 3 level arsitektur DBMS).<br>
  
                          
                            Beberapa petunjuk dalam pemilihan perancangan databasesecara fisik :<br>
  
                             a. Response time<br>
                             Waktu yang telah berlalu dari suatu transaksi database yang diajukan untuk menjalankan suatu tanggapan. Pengaruh utama pada response time adalah di    bawah pengawasan DBMS yaitu : waktu akses database untuk data item yang ditunjuk oleh suatu transaksi. Response time juga dipengaruhi oleh beberapa    faktor yang tidak berada di bawah pengawasan DBMS, seperti penjadwalan sistem operasi atau penundaan komunikasi.
                          <br>   
                            b. Space utility<br>
                           Jumlah ruang penyimpanan yang digunakan oleh file-file database dan struktur-struktur jalur akses. <br>
                          c. Transaction throughput<br>
                            Rata-rata jumlah transaksi yang dapat diproses per menit oleh sistem database, dan merupakan parameter kritis dari sistem transaksi (misal : digunakan    pada pemesanan tempat di pesawat, bank, dll). Hasil dari fase ini adalah penentual awal dari struktur penyimpanan dan jalur akses untuk file-file database.</p>
                          <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                        </div>
                      </div>
                      <div class="card">
                        <!-- <img src="..." class="card-img-top" alt="..."> -->
                        <div class="card-body">
                          <h5 class="card-title">6. Implementasi Sistem database</h5>
                          <p class="card-text">Setelah perancangan secara logika dan secara fisik lengkap, kita dapat melaksanakan sistem database. Perintah-perintah dalam DDL dan SDL(Storage Definition Language) dari DBMS yang dipilih, dihimpun dan digunakan untuk membuat skema database dan file-file database (yang kosong). Sekarang databasetersebut dimuat (disatukan) dengan datanya.Jika data harus dirubah dari sistem komputer sebelumnya, perubahan-perubahan yang rutin mungkin diperlukan untuk format ulang datanya yang kemudian dimasukkan ke database yang baru. Transaksi-transaksi database sekarang harus dilaksanakan oleh para programmmer aplikasi.Spesifikasi secara konseptual diuji dan dihubungkan dengan kode program dengan perintah-perintah dari embedded DML yang telah ditulis dan diuji. Suatu saat transaksi-transaksi tersebut telah siap dan data telah dimasukkan ke dalam database, maka tahap perancangan dan implementasi telah selesai, dan kemudian tahap operasional dari sistem database dimulai.</p>
                          <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                        </div>
                      </div>
                  </div>
            </div>
        </section>
        <!-- TBO section 4 pertemuan 9 -->
        <section class="page-section" id="tugas4">
          <div class="container">
              <!-- TBO Section Heading-->
              <h2 class="page-section-heading text-center text-uppercase text-secondary mb-0">Transaction Concept</h2>
              <!-- Icon Divider-->
              <div class="divider-custom">
                  <div class="divider-custom-line"></div>
                  <div class="divider-custom-icon"><i class="fas fa-star"></i></div>
                  <div class="divider-custom-line"></div>
              </div>
              <!-- TBO Section Card-->
              <div class="card-group mb-3">
                  <div class="card">
                    <!-- <img src="..." class="card-img-top" alt="..."> -->
                    <div class="card-body">
                      <h5 class="card-title">Transaction</h5>
                      <p class="card-text">Transaction adalah unit eksekusi program yang mengakses dan memungkinkan untuk memperbarui berbagai item data. Transaction merupakan satu fitur DBMS relasional yang cukup penting bahkan menjadi keunggulan dari DBMS relasional secara umum. <br> Dua masalah utama yang harus ditangani dalam transaksi yaitu : <br>
                          1. Berbagai jenis kegagalan, seperti kegagalan hardware dan sistem crash<br>
                          2. Eksekusi bersamaan dari beberapa transaksi<br> <br>

                          Untuk menjaga integritas data sistem database harus memastikan: <br>

                          1. Atomicity <br>
                          Semua operasi transaksi tercermin dengan benar di database atau tidak. <br>
                          
                          2. Consistency <br>
                          Data tetap konsisten baik sebelum maupun sesudah transaksi <br>
                        
                          3. Isolation <br>
                          Jika ada beberapa transaksi yang terjadi, maka transaksi yang pertama akan di eksekusi terlebih dahulu sampai selesai. Kemudian diikuti oleh transaksi yang lainnya. Isolasi dapat dilakukan dengan menjalankan transaksi secara serial. <br>
                          4. Durability <br>
                          Memastikan agar semua perubahan selama transaksi tetap tersimpan di database secara permanen meskipun transaksi yang dilakukan mengalami kegagalan.</p>
                      <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                    </div>
                  </div>
                </div>
                <div class="card-group">
                  <div class="card">
                    <!-- <img src="..." class="card-img-top" alt="..."> -->
                    <div class="card-body">
                      <h5 class="card-title">Contoh Kasus Transaction</h5>
                      <p class="card-text">Contoh kasus dari transaksi ini adalah misalnya pada suatu perpusatakaan kota terdapat seseorang yang ingin meminjam buku Sejarah. Jumlah buku sejarah yang telah dipinjam adalah adalah 15 buku dan jumlah buku Sejarah yang tersisa yaitu 3 buku.
                        Berikut adalah proses transaksinya :<br>
                          1. read (bukuDipinjam)<br>
                          2. bukuDipinjam = bukuDipinjam + 1<br>
                          3. write (bukuDipinjam) <br>
                          4. read (bukuTersisa) <br>
                          5. bukuTersisa = bukuTersisa - 1 <br>
                          6. write (bukuTersisa) <br> <br>

                          Berikut, penjelasan ACID pada contoh kasus mengenai perpusatakaan ini:<br>

                          1. Atomicity <br>
                          Semua step pada transaksi ini harus dilakukan. Jika ada step yang gagal saat melakukan transaksi, contohnya pada step yang ke-3, maka seluruh perubahan akan dibatalkan dan dikembalikan ke kondisi awal serta transaksi dianggap gagal. <br>
                          
                          2. Consistency <br>
                          Transaksi pada kasus ini dikatakan konsiten jika, jumlah stok buku Sejarah sesudah dan sebelum transaksi sama. Sebelum transaksi, jumlah buku yang tersisa yaitu 3 buku dan jumlah buku yang telah dipinjam yaitu 15 buku. Sehingga, jumlah stok buku secara keseluruhan sebelum transaksi yaitu 18 buku. Setelah transaksi dilakukan, jumlah buku Dipinjam ditambah 1 sehingga hasilnya 16 buku, dan jumlah buku yang tersisa dikurang 1 sehingga hasilnya 2 buku. Sehingga, jumlah stok buku secara keseluruhan setelah transaksi yaitu 18 buku.<br> Dan dapat disimpulkan, bahwa kasus ini dapat dikatakan konsisten karena jumlah stok buku Sejarah sesudah dan sebelum transaksi sama.<br>
                        
                          3. Isolation <br>
                          Jika ada transaksi lain yang terjadi saat transaksi yang pertama dilakukan, maka transaksi yang kedua ini harus menunggu sampai transaksi yang pertama selesai. Hal ini dilakukan untuk menjaga agar data tersebut tetap konsisten.<br>
                          4. Durability <br>
                          Setelah transaksi selesai, Semua perubahan akan disimpan didalam database meskipun ada kegagalan sistem yang terjadi.</p>
                      <!-- <p class="card-text"><small class="text-muted">Last updated 3 mins ago</small></p> -->
                    </div>
                  </div>
                </div>
          </div>
      </section>
        <!-- Footer-->
        <footer class="footer text-center">
            <div class="container">
                <div class="row">
                    <!-- Footer Location-->
                    <div class="col-lg-6 mb-5 mb-lg-0">
                        <h4 class="text-uppercase mb-4">Location</h4>
                        <p class="lead mb-0">
                            Bulukumba 
                            <br />
                            South Sulawesi, Indonesia.
                        </p>
                    </div>
                    <!-- Footer Social Icons-->
                    <div class="col-lg-6 mb-5 mb-lg-0">
                        <h4 class="text-uppercase mb-4">Around the Web</h4>
                        <a class="btn btn-outline-light btn-social mx-1" href="https://www.facebook.com/darul.ikhsan.7967"><i class="fab fa-fw fa-facebook-f"></i></a>
                        <a class="btn btn-outline-light btn-social mx-1" href="https://twitter.com/Darul37315964"><i class="fab fa-fw fa-twitter"></i></a>
                        <a class="btn btn-outline-light btn-social mx-1" href="https://www.instagram.com/drlkhsn/"><i class="fab fa-fw fa-instagram"></i></a>
                        <!-- <a class="btn btn-outline-light btn-social mx-1" href="#!"><i class="fab fa-fw fa-dribbble"></i></a> -->
                    </div>
                    <!-- Footer About Text-->
                    <!-- <div class="col-lg-4">
                        <h4 class="text-uppercase mb-4">About Freelancer</h4>
                        <p class="lead mb-0">
                            Freelance is a free to use, MIT licensed Bootstrap theme created by
                            <a href="http://startbootstrap.com">Start Bootstrap</a>
                            .
                        </p>
                    </div> -->
                </div>
            </div>
        </footer>
        <!-- Copyright Section-->
        <div class="copyright py-4 text-center text-white">
            <div class="container"><small>Copyright © Darul Ikhsan 2020</small></div>
        </div>
        <!-- Scroll to Top Button (Only visible on small and extra-small screen sizes)-->
        <div class="scroll-to-top d-lg-none position-fixed">
            <a class="js-scroll-trigger d-block text-center text-white rounded" href="#page-top"><i class="fa fa-chevron-up"></i></a>
        </div>
        <!-- Bootstrap core JS-->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.bundle.min.js"></script>
        <!-- Third party plugin JS-->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.4.1/jquery.easing.min.js"></script>
        <!-- Contact form JS-->
        <script src="assets/mail/jqBootstrapValidation.js"></script>
        <script src="assets/mail/contact_me.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
</body>
</html>
